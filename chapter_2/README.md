## 第2章 一切都是对象

**如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界。**

——Luduing Wittgerstein (1889-1951)

**尽管Java是基于C++的，但是相比之下，Java是一种更“纯粹”的面向对象程序设计语言。**

C++和Java都是混合/杂合型语言。但是，Java的设计者认为这种杂合性并不像在C++中那么重要。杂合型语言允许多种编程风格；C++之所以成为一种杂合型语言主要是因为它支持与C语言的向后兼容。因为C++是C的一个超集，所以势必包括许多C语言不具备的特性，这些特性使C++在某些方面显得过于复杂。

Java语言假设我们只进行面向对象的程序设计。也就是说，在开始用Java进行设计之前，必须将思想转换到面向对象的世界中来。这个入门基本功，可以使你具备使用这样一种编程语言编程的能力，这种语言学习起来更简单，也比许多其他OOP语言更易用。在本章，我们将看到Java程序的基本组成部分，并体会到在Java中（几乎）一切都是对象。

### 2.1 用引用操纵对象

每种编程语言都有自己的操纵内存中元素的方式。有时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C和C++里的指针）来操纵对象？

所有这一切在Java里都得到了简化。一切都被视为对象，因此可采用单一固定的语法。尽管一切都看作对象，但曹忠的标识符实际上是对象的一个“引用”（reference）（注释①）。可以将这一情形想象成用遥控器（引用）来操纵电视机（对象）。只要握住这个遥控器，就能保持与电视机的连接。当有人想改变频道或者减小音量时，实际操纵的是遥控器（引用），再由遥控器来调控电视机（对象）。如果想在房间里四处走走，同时仍能调控电视机，那么只需携带遥控器（引用）而不是电视机（对象）。

> 注释①：这可能会引起争论。有人认为：“很明显，它是一个指针。”但是这种说法是基于底层实现的某种假设。并且，Java中的引用，在语法上更接近C++的引用而不是指针。本书的第1版中，我选择发明一个新术语“句柄（handle）”来表示这一概念，因为，Java的引用和C++的引用毕竟存在一些重大差异。我当时正在脱离C++阵营，而且也不想使那些已经习惯C++语言的程序员（我想他们将来会是最大的、热衷于Java的群体）感到迷惑。在第2版中，我决定换回这个最为广泛使用的术语——“引用”。并且，那些从C++阵营转换过来的人们，理应更会处理引用，而不是仅仅理解“引用”这个属于，因而他们也会全心全意投入其中的。尽管如此，还是有人不同意用“引用”这个术语。我曾经读到的一本书这样说：“Java所支持的‘按址传递’是完全错误的”，因为Java对象标识符（按照那位作者所说）实际上是“对象引用”。并且他接着说任何事物都是“按值传递”的。也许有人会赞成这种精确却让人费解的解释，但我认为我的这种方法可以简化概念上的理解并且不会伤害到任何事物。（好了，那些语言专家可能会说我在撒谎，但我认为我只是提供了一个合适的抽象罢了。）

此外，即使没有电视机，遥控器亦可独立存在。也就是说，你拥有一个引用，并不一定需要有一个对象与它关联。因此，如果想操纵一个词或句子，则可以创建一个String引用：

```Java
String s;
```

但这里所创建的只是引用，并不是对象。如果此时向s发送一个消息，就会返回一个运行时错误。这是因为此时s实际上没有与任何事物相关联（即，没有电视机）。因此，一种安全的做法是：创建一个引用的同时便进行初始化。

```Java
String s = "asdf";
```

但这里用到了Java语言的一个特性：字符串可以用带引号的文本初始化。通常，必须对对象采用一种更通用的初始化方法。

### 2.2 必须由你创建所有对象

一旦创建了一个引用，就希望它能与一个新的对象相关联。通常用new操作符来实现这一目的。new关键字的意思是“给我一个新对象。”所以前面的例子可以写成：

```Java
String s = new String("asdf");
```

它不仅表示“给我一个新的字符串”，而且通过提供一个初始字符串，给出了怎样产生这个String的信息。

当然，除了String类型，Java提供了大量过剩的现成类型。重要的是，你可以自行创建类型。事实上，这是Java程序设计中一项基本行为，你会在本书以后章节中慢慢学到。

#### 2.2.1 存储到什么地方

程序运行时，对象是怎么进行放置安排的呢？特别是内存是怎样分配的呢？对这些方面的了解会对你有很大的帮助。有五个不同的地方可以存储数据：

1）**寄存器**。这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量及其有限，所以寄存器根据需求进行分配。你不能直接控制，也不能再程序中感觉到寄存器存在的任何迹象（另一方先，C和C++允许您向编译器建议寄存器的分配方式）。

2）**堆栈**。位于通用RAM（随机访问存储器）中，但通过堆栈指针可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中——特别是对象引用，但是Java对象并不存储于其中。

3）**堆**。一种通用内存池（也位于RAM区），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配有很大的灵活性。当需要一个对象时，只需用new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代价：用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间（如果确实可以在Java中像C++中一样在栈中创建对象）。

4）**常量存储**。常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分分隔离开，所以在这种情况下，可以选择将其存放在ROM（只读存储器）中（注释①）。

> 注释①：这种存储区的一个例子是字符串池。所有字面常量子弹飞赌船和具有字符串值的常量表达式都自动是内存限定的，并且会置于特殊的静态存储区中。

5）**非RAM存储**。如果数据完全存活于程序之外，那么它可能不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是流对象和持久化对象。在流对象中，对象转化成字节流，通常被发送给另一台机器。在“持久化对象”中，对象被存放于磁盘上，因此，即使程序终止，它们仍可以保持自己的状态。这种存储方式的技巧在于：把对象转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的、基于RAM的对象。Java提供了对轻量级持久化的支持，而诸如JDBC和Hibernate这样的机制提供了更加复杂的对在数据库中存储和读取对象信息的支持。

#### 2.2.2 特例：基本类型

在程序设计中经常用到的一系列类型，它们需要特殊对待。可以把它们想象成“基本”类型。之所以特殊对待，是因为new将对象存储在“堆”里，故用new创建一个对象——特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，Java采取与C和C++相同的方法。也就是说，不用new来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。

Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随极其硬件架构的变化而变化。这种所占据存储空间大小的不变性是Java程序比用其他大多数语言编写的程序更具可移植性的原因之一。

基本类型|大小|最小值|最大值|包装器类型
--- | --- | --- | --- | ---
boolean | - | - | - | Boolean
char | 16-bit | Unicode o | Unicode 2^16-1 | Character
byte | 8 bits | -128 | +127 | Byte
short | 16 bits | -2^15 | +2^15-1 | Short
int | 32 bits | -2^31 | +2^31-1 | Integer
long | 64 bits | -2^63 | +2^63-1 | Long
float | 32 bits | IEEE754 | IEEE754 | Float
double | 64 bits | IEEE754 | IEEE754 | Double
void | - | - | - | Void

所有数值类型都有正负号，所以不要去寻找无符号的数值类型。

boolean类型所占存储空间的大小没有明确指定，仅定义为能够取字面值true或false。

基本类型具有的包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。例如：

```Java
char c = 'x';
Chatacter ch = new Character(c);
```

也可以这样用：

```Java
Character ch = new Character('x');
```

Java SE5的自动包装功能将自动地将基本类型转换为包装器类型：

```Java
Character ch = 'x';
```

并可以反向转换：

```Java
char c = ch;
```

包装基本类型的原因将在以后的章节中说明。

**高精度数字**

Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。虽然它们大体上属于“包装器类”的范畴，但而这都没有对应的基本类型。

不过，这两个类包含的方法，提供的操作与对基本类型所能执行的操作相似。也就是说，能作用于int或float的操作，也同样能作用于BigInteger或BigDecimal。只不过必须以方法调用方式取代运算符方式来实现。由于这么做复杂了许多，所以运算速度会比较慢。在这里，我们以速度换取了精度。

BigInteger支持任意精度的整数。也就是说，在运算中，可以准确地表示任何大小的整数值，而不会丢失任何信息。

BigDecimal支持任何精度的定点数，例如，可以用它进行精确的货币计算。

关于调用这两个类的构造器和方法的详细信息，请查阅JDK文档。

#### 2.2.3 Java中的数组

几乎所有的程序设计语言都支持数组。在C和C++中国使用数组是很危险的，因为C和C++中的数组就是内存块。如果一个程序要访问其自身内存块之外的数组，或在数组初始化前使用内存（程序中常见的错误），都会产生难以预料的后果。

Java的主要目标之一就是安全性，所以许多在C和C++里困扰程序员的问题在Java里不会再出现。Java确保数组会被初始化，而且不能再它的范围之外被访问。这种范围检查，是以每个数组上少量的内存开销及运行时的下标检查为代价的。但由此换来的是安全性和效率的提高，因此付出的代价是值得的（并且Java有时可以优化这些操作）。

当创建一个数组对象时，实际上就是创建了一个引用数组，并且每个引用都会自动被初始化为一个特定值，该值拥有自己的关键字null。一旦Java看到null，就知道这个引用还没有指向某个对象。在使用任何引用前，必须为其制定一个对象；如果试图使用一个还是null的引用，在运行时将会报错。因此，常犯的数组错误在Java中就可以避免。

还可以创建用来存放基本数据类型的数组。同样，编译器也能确保这种数组的初始化，因为它会将这种数组所占的内存全部置零。

数组将在以后的章节中详细讨论。

### 2.3 永远不需要销毁对象

在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作中非常重要的部分。变量需要存活多长时间？如果想要销毁对象，那什么时刻进行呢？变量生命周期的混乱往往会导致大量的程序bug，本节将介绍Java是怎样替我们完成所有的清理工作，从而大大地简化这个问题的。

#### 2.3.1 作用域

大多数过程型语言都有作用域（scope）的概念。作用域决定了在其内定义的变量名的可见性和生命周期。在C、C++和Java中，作用域由花括号的位置决定。例如：

```Java
{
    int x = 12;
    // Only x available
    {
        int q = 96;
        // Both x & q available
    }
    // Only x available
    // q is "out of scope"
}
```

在作用域里定义的变量只可用于作用域结束之前。

任何位于“//”之后到行末的文字都是注释。

缩排格式使Java代码更易于阅读。由于Java是一种自由格式（free-from）的语言，所以，空格、制表符、换行都不会影响程序的执行结果。

尽管以下代码再C和C++中是合法的，但是在Java中却不能这样书写：

```Java
{
    int x = 12;
    {
        int x = 96; // Illegal
    }
}
```

编译器将会报告变量x已经定义过。所以，在C和C++里将一个大作用域的变量“隐藏”起来的做法，在Java里是不允许的。因为Java设计者认为这样会导致程序混乱。

#### 2.3.2 对象的作用域

Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。所以加入你采用代码：

```Java
{
    String s = new String("a String");
} // End of scope
```

引用s在作用域终点就消失了。然而，s指向的String对象仍继续占据内存空间。在这一小段代码中，我们无法在这个作用域之后访问这个对象，因为对它唯一的引用已超出了作用域的范围。在后续章节中，读者将会看到：在程序执行过程中，怎样传递和复制对象引用。

事实证明，由new创建的对象，只要你需要，就会一直保留下去。这样，许多C++编程问题在Java中就完全消失了。在C++中，你不仅必须要确保对象的保留时间与你需要这些对象的时间一样长，而且还必须在你使用完它们之后，将其销毁。

这样便带来一个有趣的问题。如果Java让对象继续存在，那么靠什么才能防止这些对象填满内存空间，进而阻塞你的程序呢？这正是C++里可能会发生的问题。这也是Java神奇之所在。Java有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，一边供其他新的对象使用。也就是说，你根本不必担心内存回收的问题。你只需要创建对象，一旦不再需要，它们就会自行消失。这样做就消除了这类编程问题（即“内存泄露”），这是由于程序员忘记释放内存而产生的问题。

### 2.4 创建新的数据类型：类

如果一切都是对象，那么是什么决定了某一类对象的外观与行为呢？