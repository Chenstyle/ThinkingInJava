# 第三章 万物皆对象

> 如果我们说另外一种不同的语言，我们会发觉一个不同的世界！——Ludwig Wittgenstein (1889-1951)

相比C++，Java是一种更纯粹的面向对象编程语言。虽然它们都是混合语言，但在Java中，设计者们认为混合的作用并非像在C++中那般重要。混合语言允许多种编程风格，这也是C++支持向后兼容C的原因。正因为C++是C语言的超集，所以它也同时包含了许多C语言不具备的特性，这使得C++在某些方面过于复杂。

Java语言假设你只进行面向对象编程。开始学习之前，我们需要将思维置于面向对象的世界。本章你将了解到Java程序的基本组成，学习在Java中万物（几乎）皆对象的思想。

## 对象操纵

“名字代表什么？玫瑰即使不叫玫瑰，也依旧芬芳。”（引用自 莎士比亚，《罗密欧与朱丽叶》）。

所有的编程语言都会操纵内存中的元素。有时程序员必须要有意识的直接或间接的操纵它们。在C/C++中，对象的操纵是通过指针来完成的。

Java利用万物皆对象的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的“引用”[^1]。举例：我们可以用遥控器（引用）去操纵电视（对象）。只要拥有对象的“引用”，就可以操纵该“对象”。换句话说，我们无需直接接触电视，就可通过遥控器（引用）自由地控制电视（对象）的频道和音量。此外，没有电视，遥控器也可以单独存在。就是说，你仅仅有一个“引用”并不意味着你必然有一个与之关联的“对象”。

> [^1]：这里可能有争议。有人说这是一个指针，但这假定了一个潜在的实现。此外，Java引用的语法更类似于C++引用而非指针。在《Thinking in Java》的第一版中，我发明了一个新术语叫“句柄”（handle），因为C++引用和Java引用有一些重要的区别。作为一个从C++的过来人，我不想混淆Java可能的最大受众——C++程序员。在《Thinking in Java》的第二版中，我认为“引用”（reference）是更常用的术语，从C++转过来的人除了引用的术语之外，还有很多东西需要处理，所以他们不妨双脚都跳进去。但是，也有些人甚至不同意“引用”。在某书中我读到一个观点：Java支持引用传递的说法是完全错误的，因为Java对象标识符（根据该作者）实际上是“对象引用”（Object references），并且一切都是值传递。所以你不是通过引用传递，而是“通过值传递对象引用。人们可以质疑我的这种解释的准确性，但我认为我的方法简化了对概念的理解而又没对语言造成伤害（嗯，语言专家可能会说我骗你，但我会说我只是对此进行了适当的抽象。）”

下面来创建一个String引用，用于保存单词或语句。代码示例：

```java
String s;
```

这里我们只是创建了一个String对象的引用，而非对象。直接拿来使用会出现错误：因为此时你并没有给变量s赋值——指向任何对象。通常更安全的做法是：创建一个引用的同事进行初始化。代码示例：

```java
String s = "asdf";
```

Java语法允许我们使用带双引号的文本内容来初始化字符串。同样，其他类型的对象也有相应的初始化方式。

## 对象创建

“引用”用来关联“对象”。在Java中，通常我们使用new操作符来创建一个新对象。new关键字代表：创建一个新的对象实例。所以，我们也可以这样来表示前面的代码示例：

```java
String s = new String("asdf");
```

以上展示了字符串对象的创建过程，以及如何初始化生成字符串。除了String类型以外，Java本身自带了许多现成的数据类型。除此之外，我们还可以创建自己的数据类型。事实上，这是Java程序设计中的一项基本行为。在本书后面的学习中将会接触到。

## 数据存储

那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据：

1. 寄存器（Regiters）最快的存储区域，位于CPU内部。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另外，C/C++允许开发者向编译器建议寄存器的分配）。

2. 栈内存（Stack）存在于常规内存RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些Java数据（如对象引用），但Java对象本身的数据却是保存在堆内存的。

3. 堆内存（Heap）这是一种通用的内存池（也在RAM区域），所有Java对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用new命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用Java在栈内存上创建对象，就像在C++中那样的话）。随着时间的推移，Java的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。

4. 常量存储（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器ROM（只读存储器，Read Only Memory）中。

5. 非RAM存储（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于RAM的对象。Java为轻量级持久化提供了支持。而诸如JDBC和Hibernate这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。

## 基本类型的存储

有一组类型在Java中使用频率很高，它们需要特殊对待，这就是Java的基本类型。之所以这么说，是因为它们的创建并不是通过new关键字来产生。通常new出来的对象都是保存在堆内存中的，以此方法创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java使用了和C/C++一样的策略。也就是说，不是使用new创建变量，而是使用一个“自动”变量。这个变量直接存储“值”，并置于栈内存中，因此更加高效。

Java确定了每种基本类型的内存占用大小。这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是Java更具可移植性的一个原因。

基本类型|大小|最小值|最大值|包装类型
--- | --- | --- | --- | ---
boolean | — | — | — | Boolean
char | 16 bits | Unicode 0 | Unicode 2^16 -1 | Character
byte | 8 bits | -128 | +127 | Byte
short | 16 bits | - 2^15 | + 2^15 -1 | Short
int | 32 bits | - 2^31 | + 2^31 -1 | Integer
long | 64 bits | - 2^63 | + 2^63 -1 | Long
float | 32 bits | IEEE754 | IEEE754 | Float
double | 64 bits | IEEE754 | IEEE754 | Double
void | — | — | — | Void

所有的数值类型都是有