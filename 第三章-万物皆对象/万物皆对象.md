# 第三章 万物皆对象

> 如果我们说另外一种不同的语言，我们会发觉一个不同的世界！——Ludwig Wittgenstein (1889-1951)

相比C++，Java是一种更纯粹的面向对象编程语言。虽然它们都是混合语言，但在Java中，设计者们认为混合的作用并非像在C++中那般重要。混合语言允许多种编程风格，这也是C++支持向后兼容C的原因。正因为C++是C语言的超集，所以它也同时包含了许多C语言不具备的特性，这使得C++在某些方面过于复杂。

Java语言假设你只进行面向对象编程。开始学习之前，我们需要将思维置于面向对象的世界。本章你将了解到Java程序的基本组成，学习在Java中万物（几乎）皆对象的思想。

## 对象操纵

“名字代表什么？玫瑰即使不叫玫瑰，也依旧芬芳。”（引用自 莎士比亚，《罗密欧与朱丽叶》）。

所有的编程语言都会操纵内存中的元素。有时程序员必须要有意识的直接或间接的操纵它们。在C/C++中，对象的操纵是通过指针来完成的。

Java利用万物皆对象的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的“引用”[^1]。举例：我们可以用遥控器（引用）去操纵电视（对象）。只要拥有对象的“引用”，就可以操纵该“对象”。换句话说，我们无需直接接触电视，就可通过遥控器（引用）自由地控制电视（对象）的频道和音量。此外，没有电视，遥控器也可以单独存在。就是说，你仅仅有一个“引用”并不意味着你必然有一个与之关联的“对象”。

> [^1]：这里可能有争议。有人说这是一个指针，但这假定了一个潜在的实现。此外，Java引用的语法更类似于C++引用而非指针。在《Thinking in Java》的第一版中，我发明了一个新术语叫“句柄”（handle），因为C++引用和Java引用有一些重要的区别。作为一个从C++的过来人，我不想混淆Java可能的最大受众——C++程序员。在《Thinking in Java》的第二版中，我认为“引用”（reference）是更常用的术语，从C++转过来的人除了引用的术语之外，还有很多东西需要处理，所以他们不妨双脚都跳进去。但是，也有些人甚至不同意“引用”。在某书中我读到一个观点：Java支持引用传递的说法是完全错误的，因为Java对象标识符（根据该作者）实际上是“对象引用”（Object references），并且一切都是值传递。所以你不是通过引用传递，而是“通过值传递对象引用。人们可以质疑我的这种解释的准确性，但我认为我的方法简化了对概念的理解而又没对语言造成伤害（嗯，语言专家可能会说我骗你，但我会说我只是对此进行了适当的抽象。）”

下面来创建一个String引用，用于保存单词或语句。代码示例：

```java
String s;
```

这里我们只是创建了一个String对象的引用，而非对象。直接拿来使用会出现错误：因为此时你并没有给变量s赋值——指向任何对象。通常更安全的做法是：创建一个引用的同事进行初始化。代码示例：

```java
String s = "asdf";
```

Java语法允许我们使用带双引号的文本内容来初始化字符串。同样，其他类型的对象也有相应的初始化方式。

## 对象创建

“引用”用来关联“对象”。在Java中，通常我们使用new操作符来创建一个新对象。new关键字代表：创建一个新的对象实例。所以，我们也可以这样来表示前面的代码示例：

```java
String s = new String("asdf");
```

以上展示了字符串对象的创建过程，以及如何初始化生成字符串。除了String类型以外，Java本身自带了许多现成的数据类型。除此之外，我们还可以创建自己的数据类型。事实上，这是Java程序设计中的一项基本行为。在本书后面的学习中将会接触到。

### 数据存储

那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据：

1. 寄存器（Regiters）最快的存储区域，位于CPU内部。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另外，C/C++允许开发者向编译器建议寄存器的分配）。

2. 栈内存（Stack）存在于常规内存RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些Java数据（如对象引用），但Java对象本身的数据却是保存在堆内存的。

3. 堆内存（Heap）这是一种通用的内存池（也在RAM区域），所有Java对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用new命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用Java在栈内存上创建对象，就像在C++中那样的话）。随着时间的推移，Java的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。

4. 常量存储（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器ROM（只读存储器，Read Only Memory）中。

5. 非RAM存储（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于RAM的对象。Java为轻量级持久化提供了支持。而诸如JDBC和Hibernate这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。

### 基本类型的存储

有一组类型在Java中使用频率很高，它们需要特殊对待，这就是Java的基本类型。之所以这么说，是因为它们的创建并不是通过new关键字来产生。通常new出来的对象都是保存在堆内存中的，以此方法创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java使用了和C/C++一样的策略。也就是说，不是使用new创建变量，而是使用一个“自动”变量。这个变量直接存储“值”，并置于栈内存中，因此更加高效。

Java确定了每种基本类型的内存占用大小。这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是Java更具可移植性的一个原因。

基本类型|大小|最小值|最大值|包装类型
--- | --- | --- | --- | ---
boolean | — | — | — | Boolean
char | 16 bits | Unicode 0 | Unicode 2^16 -1 | Character
byte | 8 bits | -128 | +127 | Byte
short | 16 bits | - 2^15 | + 2^15 -1 | Short
int | 32 bits | - 2^31 | + 2^31 -1 | Integer
long | 64 bits | - 2^63 | + 2^63 -1 | Long
float | 32 bits | IEEE754 | IEEE754 | Float
double | 64 bits | IEEE754 | IEEE754 | Double
void | — | — | — | Void

所有的数值类型都是有正/负符号的。布尔（boolean）类型的大小没有明确的规定，通常定义为取字面值“true”或“false”。基本类型都有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。代码示例：

```java
char = 'x';
Character ch = new Character(c);
```

或者你也可以使用下面的形式：

```java
Character ch = new Character('x');
```

基本来兴自动转换成包装类型（自动装箱）

```java
Character ch = 'x';
```

相对的，包装类型转化为基本类型（自动拆箱）：

```java
char c = ch;
```

各种原因将在以后的章节里解释。

### 高精度数值

在Java中有两种类型的数据可用于高精度的计算。它们是BigInteger和BigDecimal。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。

这两个类包含的方法提供的操作，与对基本类型的操作很相似。也就是说，能对int或float做的运算，在BigInteger和BigDecimal这里也同样可以，只不过必须要通过调用它们的方法来实现而非运算符。此外，由于涉及到的计算量更多，所以运算速度会慢一些。诚然，我们牺牲了速度，但换来了精度。

BigInteger支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。BigDecimal支持任意精度的定点数字。例如，可用它进行精确的货币计算。

关于这两个类的详细信息，请参考JDK官方文档。

### 数组的存储

许多编程语言都支持数组类型。在C和C++中使用数组是很危险的，因为那些数组只是内存块。如果程序访问了内存块之外的数组或在初始化钱使用该段内存（常见编程错误），则结果是不可预测的。

Java的设计主要目标之一是安全性，因为许多困扰C和C++程序员的问题不会在Java中出现。在Java中，数组使用前需要被初始化，并且不能访问数组长度以外的我数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。（并且Java经常可以优化这些操作）。

当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为null。在使用该数组之前，我们必须为每个引用指定一个对象。如果我们尝试使用为null的引用，则会在运行时报错。因此，在Java中就防止了数组操作的常规错误。

我们还可以创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。本书稍后将详细介绍数组，特别是在数组章节中。

## 代码注释

Java中有两种类型的注释。第一种是传统的C风格的注释，以\/\*开头，可以跨越多行。到\*\/结束。注意，许多程序员在多行注释的每一行开头添加\*，所以你经常会看到：

```java
/* 这是
* 跨越多行的
* 注释
*/
```

但请记住，\/\*和\*\/之间的内容都是被忽略的。所以你将其改为下面这样也是没有区别的。

```java
/* 这是跨越多
行的注释 */
```

第二种注释形式来自C++。它是单行注释，以\/\/开头并一直持续到行结束。这种注释方便日常用，因为直观简单。所以你经常看到：

```java
// 这是单行注释
```

## 对象清理

在一些编程语言中，管理变量的生命周期需要大量的工作。一个变量需要存活多久？如果我们想要销毁它，应该什么时候去做呢？变量生命周期的混乱会导致许多bug，本小结向你介绍java是如何通过释放存储来简化这个问题的。

### 作用域

大多数程序语言都有作用域的概念。作用域决定了在该范围内定义的变量名的可见性和生存周期。在C、C++和Java中，作用域是由大括号{}的位置决定的。例如：、

```java
{
    int x = 12;
    // 仅 x 变量可用
    {
        int q = 96;
        // x 和 q 变量皆可用
    }
    // 仅 x 变量可用
    // 变量 q 不在作用域内
}
```

Java的变量只有在其作用域内才可使用。缩进使得Java代码更易于阅读。由于Java是一种自由格式的语言，额外的空格、制表符和回车并不会影响程序的执行结果。在Java中，你不能执行以下操作，即使这在C和C++中是合法的。

```java
{
    int x = 12;
    {
        int x = 96;
    }
}
```

在上例中，Java编译器会在提示变量x已经被定义过了。因此，在C/C++中将一个较大作用域的变量“隐藏”起来的做法，在Java中是不被允许的。因为Java的设计者认为这样会导致程序混乱。

### 对象作用域

Java对象与基本类型具有不同的生命周期。当我们使用new关键字来创建Java对象时，它的生命周期将会超出作用域。因此，下面这段代码示例：

```java
{
    String s = new String("a string");
}
// 作用域终点
```

上例中，引用s在作用域终点就结束了。但是，引用s指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它引用s已超出了作用域的范围。在后面的章节中，我们还会学习怎么在编程中传递和复制对象的引用。

只要你需要，new出来的对象就会一直存活下去。相比在C++编码中操作内存可能会出现的诸多问题，这些困扰在Java中都不复存在了。在C++中你不仅要确保对象的内存在你操作的范围内存在，还必须在使用完它们之后，将其销毁。

那么问题来了：我们在Java中并没有主动清理这些对象，那么它是如何避免C++中出现的内存被填满从而阻塞程序的问题呢？答案是：Java的垃圾收集器会检查所有new出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄露”问题。

## 类的创建

### 类型

如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型？你可能很自然地想到type关键字。但是，事实上大多数面向对象的语言都是用class关键字来描述一种新的对象。通常在class关键字的后面紧跟类的名称。如下代码示例：

```java
class ATypeName {
    // 这是类的内部
}
```

在上例中，我们引入了一个新的类型，尽管这个类里只有一行注释。但是我们一样可以通过new关键字来创建一个这种类型的对象。如下：

```java
ATypeName a = new ATypeName();
```

到现在为止，我们还不能用这个对象来做什么事（即不能向它发送任何有意义的消息），除非我们在这个类里定义一些方法。

### 字段

当我们创建好一个类之后，我们可以往类里存放两种类型的元素：方法（method）和字段（field）。类的字段可以是基本类型，也可以是引用类型。如果类的字段是对某个对象的引用，那么必须要初始化该引用将其关联到一个实际的对象上（通过支起按介绍的创建对象的方法）。每个对象都有用来存储其字段的空间。通常，字段不再对象间共享。下面是一个具有某些字段的类的代码示例：

```java
class DataOnly {
    int i;
    double d;
    boolean b;
}
```

这个类除了存储数据之外什么也不能做。但是，我们仍然可以通过下面的代码来创建它的一个对象：

```java
DataOnly data = new DataOnly();
```

我们必须通过这个对象的引用来指定字段值。格式：对象的名称.方法名称或字段名称。代码示例：

```java
data.i = 47;
data.d = 1.1;
data.b = false;
```

如果你想修改对象内部包含的另一个对象的数据，可以通过这样的格式修改。代码示例：

```java
myPlane.leftTank.capacity = 100;
```

你可以用这种方式嵌套许多对象（尽管这样的设计会带来混乱）。

### 基本类型默认值

如果类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。

基本类型 | 初始值
--- | ---
boolean | false
char | \u000(null)
byte | (byte)0
short | (short)0
int | 0
long | 0L
float | 0.0f
double | 0.0d

这些默认值仅在Java初始化的时候才会被赋予。这种方式确保了基本类型的字段始终能被初始化（在C++中不会），从而减少了bug的来源。但是，这些初始值对于程序来说并不一定是合法或者正确的。所以，为了安全，我们最好始终显式的初始化变量。

这种默认值的赋予并不适用于局部变量——那些不属于类的字段的变量。因此，若在方法中定义的基本类型数据，如下：

```java
int x;
```

这里的变量x不会自动初始化为0，因为在使用变量x之前，程序员有责任主动地为其赋值（和C、C++一致）。如果我们忘记了这一步，Java将会提示我们“编译时错误，该变量可能尚未被初始化”。这一点做得比C++更好，在后者中，编译器只是提示警告，而在Java中则直接报错。

### 方法使用

在许多语言（如C和C++）中，使用术语函数（function）用来命名子程序。在Java中，我们使用术语方法（method）来表示“做某事的方式”。

在Java中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。格式如：

```java
 [返回类型] [方法名](/*参数列表*/){
     // 方法体
 }
```